#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Edge
{
    int src;
    int dest;
};

struct Graph
{
    int vertexesCount;
    int edgesCount;
    Edge **edges;
};

struct Subset
{
    int parent;
    int rank;
};

Edge *createEdge(int src, int dest)
{
    Edge *e = (Edge *)malloc(sizeof(Edge));
    e->src = src;
    e->dest = dest;
    return e;
}

Graph *createGraph(int vertexesCount, int edgesCount)
{
    Graph *g = (Graph *)malloc(sizeof(Graph));
    g->vertexesCount = vertexesCount;
    g->edgesCount = edgesCount;
    g->edges = (Edge **)malloc(sizeof(Edge *) * edgesCount);
    return g;
}

int findRoot(int parent[], int edge)
{
    if (parent[edge] == -1)
        return edge;
    return findRoot(parent, parent[edge]);
}

void doUnion(int parent[], int rootParent1, int rootParent2)
{
    parent[rootParent1] = rootParent2;
}

bool isCycle(Graph *graph)
{
    int parent[100000];

    memset(parent, -1, sizeof(parent));

    for (int i = 0; i < graph->edgesCount; i++)
    {
        int srcRootParent = findRoot(parent, graph->edges[i]->src);
        int destRootParent = findRoot(parent, graph->edges[i]->dest);

        if (srcRootParent == destRootParent)
            return true;

        doUnion(parent, srcRootParent, destRootParent);
    }

    return false;
}

int main()
{
    // FALSE
    Graph *graph = createGraph(2, 2);

    graph->edges[0] = createEdge(0, 1);
    graph->edges[1] = createEdge(1, 2);

    // TRUE
    // Graph *graph = createGraph(3, 3);

    // graph->edges[0] = createEdge(0, 1);
    // graph->edges[1] = createEdge(1, 2);
    // graph->edges[2] = createEdge(0, 2);

    puts(isCycle(graph) ? "true" : "false");

    return 0;
}

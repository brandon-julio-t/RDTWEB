@page "/TestAnswer/{id?}"

@using Microsoft.AspNetCore.Hosting
@using System.IO
@using System.Transactions
@using Microsoft.Extensions.Logging

@attribute [Authorize(Roles = "Admin, Participant")]

@inject ApplicationDbContext _context
@inject AuthenticationStateProvider _authenticationStateProvider
@inject UserManager<IdentityUser> _userManager
@inject IWebHostEnvironment _env

<h3>Information</h3>

<ServerTime />

<div class="table-responsive">
    <table class="table table-bordered table-hover">
        <tbody>
        <tr>
            <th>Title</th>
            <td>@QuestionSet.Title</td>
        </tr>
        <tr>
            <th>Start At</th>
            <td>@QuestionSet.StartAt</td>
        </tr>
        <tr>
            <th>End At</th>
            <td>@QuestionSet.EndAt</td>
        </tr>
        </tbody>
    </table>
</div>

<section>
    @for (var i = 0; i < QuestionSet.Questions.Count; i++)
    {
        var question = QuestionSet.Questions[i];

        <div class="my-4 p-4 border rounded">
            <p>
                @(i + 1).
                <span class="font-weight-bold">@question.Body</span>
            </p>

            @switch (question.Type)
            {
                case "Multiple Choice":
                case "Multiple Answer List":
                    @for (var j = 0; j < question.Choices.Count; j++)
                    {
                        var idx = j;

                        <div class="form-group form-inline">
                            <input @onchange="() => question.Answer.ChosenIndex = idx" checked="@(question.Answer.ChosenIndex == idx)" class="form-check-input" type="checkbox"/>
                            <input disabled value="@question.Choices[idx]" type="text" class="form-control flex-fill" placeholder="Multiple Answer Choice #@(idx + 1)"/>
                        </div>
                    }
                    break;

                case "Boolean (true or false)":
                    <div class="form-group">
                        <div class="form-check form-check-inline">
                            <input @onchange="() => question.Answer.BooleanAnswer = true" checked="@question.Answer.BooleanAnswer" class="form-check-input" type="radio" id="true">
                            <label class="form-check-label" for="true">True</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input @onchange="() => question.Answer.BooleanAnswer = false" checked="@(!question.Answer.BooleanAnswer)" class="form-check-input" type="radio" id="false">
                            <label class="form-check-label" for="false">False</label>
                        </div>
                    </div>
                    break;

                case "Essay":
                    <div class="form-group">
                        <textarea @bind="question.Answer.StringAnswer" class="form-control" rows="7"></textarea>
                    </div>
                    break;

                case "Submit File":
                    <div class="form-group">
                        <InputFile OnChange="e => question.Answer.BrowserFile = e.File" class="form-control-file"/>
                    </div>

                    <ViewFileInfo FilePath="@question.Answer.StringAnswer"/>
                    break;
            }
        </div>
    }
</section>

@if (AreAnswersSaved)
{
    <div class="alert alert-success alert-dismissible fade show" role="alert">
        Answers saved.
        <button @onclick="() => AreAnswersSaved = false" type="button" class="close" data-dismiss="alert" aria-label="Close">
            <span aria-hidden="true">&times;</span>
        </button>
    </div>
}

<button @onclick="OnSave" class="btn btn-success">Save</button>
<NavLink href="/TestSchedules" class="btn btn-secondary">Back</NavLink>

@code {

    [Parameter]
    public string Id { get; set; }

    private QuestionSet QuestionSet { get; set; }
    private bool AreAnswersSaved { get; set; }

    protected override async Task<Task> OnInitializedAsync()
    {
        var state = await _authenticationStateProvider.GetAuthenticationStateAsync();
        var userId = _userManager.GetUserId(state.User);

        QuestionSet = _context.QuestionSets
            .Include(questionSet => questionSet.Questions)
            .ThenInclude(question => question.Answers.Where(answer => answer.UserId == userId))
            .AsSplitQuery()
            .Single(questionSet => questionSet.Id.ToString() == Id);

        QuestionSet.Questions
            .ForEach(question =>
                question.Answer = question.Answers
                    .SingleOrDefault(answer => answer.UserId == userId)
                                  ?? new Answer {UserId = userId, QuestionId = question.Id});

        return base.OnInitializedAsync();
    }

    private void OnSave()
    {
        QuestionSet.Questions.ForEach(async question =>
        {
            if (question.Type != "Submit File" || question.Answer.BrowserFile == null)
                return;

            var previousPath = question.Answer.StringAnswer;

            var name = question.Answer.BrowserFile.Name;
            var extension = name[name.LastIndexOf(".", StringComparison.Ordinal)..];

            var path = Path.Combine("Storage", "Answers", Path.GetRandomFileName() + extension);
            await using var file = File.Create(path);
            file.Seek(0, SeekOrigin.Begin);
            await question.Answer.BrowserFile.OpenReadStream(512000000).CopyToAsync(file);

            question.Answer.StringAnswer = path;
            question.Answer.BrowserFile = null;

            if (string.IsNullOrWhiteSpace(previousPath))
                return;
            
            var absolutePath = Path.Combine(_env.ContentRootPath, previousPath);
            File.Delete(absolutePath);
        });

        var answers = QuestionSet.Questions.Select(question => question.Answer).ToList();

        try
        {
            _context.AddRange(answers);
            _context.SaveChanges();
        }
        catch (DbUpdateException)
        {
    // Entity exists, update it instead.
            _context.UpdateRange(answers);
            _context.SaveChanges();
        }

        AreAnswersSaved = true;
    }

}